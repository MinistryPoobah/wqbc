cv <- function (x) {
  if(length(x) == 1)
    return (0)
  if(mean(x) == 0)
    return (0)
  sd(x) / mean(x)
}

abs_dev <- function (x) {
  abs(x - mean(x))
}

clean_wqdata_replicates <- function (x, max_cv, messages) {
  n <- nrow(x)
  cv <- cv(x$Value)
  if(cv(x$Value) > max_cv && nrow(x) > 2) {
    x <- dplyr::arrange_(x, ~-Value)
    while(cv(x$Value) > max_cv && nrow(x) > 2) {
      x <- x[-which.max(abs_dev(x$Value)),]
    }
  }
  x$Value <- mean(x$Value)

  if(!is.null(x$DetectionLimit))
    x$DetectionLimit <- mean(x$DetectionLimit)

  if(messages && n > nrow(x)) {
    message("Filtered ", n - nrow(x), " of ", n,
            " replicate values with a CV of ", signif(cv, 3), " for ", x$Variable[1],
            " on ", x$Date[1], ".")
  }
  x[1,,drop = FALSE]
}

clean_wqdata_variable <- function (x, max_cv, messages) {
  if(anyDuplicated(x$Date))
    x <- plyr::ddply(x, "Date", clean_wqdata_replicates, max_cv = max_cv,
                     messages = messages)
  x
}

clean_wqdata_by <- function (x, max_cv, messages) {
  if(anyDuplicated(x$Variable))
    x <- plyr::ddply(x, "Variable", clean_wqdata_variable, max_cv = max_cv,
                     messages = messages)
  x
}

#' Clean Water Quality Data
#'
#' Cleans water quality data. After standardization using \code{\link{standardize_wqdata}}
#' replicates (two or more readings for the same variable on the same date) are averaged
#' using the \code{mean} function.
#' Readings for the same variable on the same date but at different levels of the
#' columns specified in by are not considered replicates. The \code{clean_wqdata}
#' function is automatically called by \code{\link{calc_limits}} prior
#' to calculating limits.
#'
#' @details If there are three or more replicates with a coefficient of variation (CV) in
#' exceedance of \code{max_cv} then the replicates with the highest absolute deviation
#' is dropped until the CV is less than or equal to \code{max_cv}
#' or only two values remain. The default value max_cv value of 1.29
#' is exceeded by two zero and one positive value (CV = 1.73)
#' or by two identical positive values and a third value an order
#' or magnitude greater (CV = 1.30). It is not exceed by one zero
#' and two identical positive values (CV = 0.87).
#'
#' @param x The data.frame to clean.
#' @param by A character vector of the columns in x to perform the cleaning by.
#' @param max_cv A number indicating the maximum permitted coefficient
#' of variation for replicates.
#' @param messages A flag indicating whether to print messages.
#' @examples
#' clean_wqdata(wqbc::dummy, messages = TRUE)
#' @seealso \code{\link{calc_limits}} and \code{\link{standardize_wqdata}}
#' @export
clean_wqdata <- function (x, by = NULL, max_cv = 1.29,
                          messages = getOption("wqbc.messages", default = TRUE)) {
  assert_that(is.data.frame(x))
  assert_that(is.null(by) || (is.character(by) && noNA(by)))
  assert_that(is.number(max_cv))
  assert_that(is.flag(messages) && noNA(messages))

  x <- add_missing_columns(x, list("Date" = as.Date("2000-01-01")), messages = messages)
  check_class_columns(x, list("Date" = "Date"))

  if("DetectionLimit" %in% colnames(x))
    check_class_columns(x, list("DetectionLimit" = "numeric"))

  x <- standardize_wqdata(x, messages = messages)
  if(messages) message("Cleaning water quality data...")
  res <- c("Date", "Variable", "Value", "Units", "DetectionLimit")
  check_by(by, colnames(x), res_names = res)
  x <- del_cols_not_in_y(x, c(res, by))

  if(is.null(by)) {
    x <- clean_wqdata_by(x, max_cv = max_cv, messages = messages)
  } else {
    x <- plyr::ddply(x, .variables = by, .fun = clean_wqdata_by, max_cv = max_cv,
                     messages = messages)
  }
  if(messages) message("Cleansed water quality data.")
  x
}
